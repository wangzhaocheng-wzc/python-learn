<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python语言进阶</title>
    <link rel="stylesheet" href="https://cdn.staticfile.org/tailwindcss/2.2.19/tailwind.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&display=swap">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js"></script>
    <style>
        /* 基础样式设置 */
        :root {
            --primary-color: #3B82F6;
            --primary-dark: #2563EB;
            --secondary-color: #10B981;
            --accent-color: #8B5CF6;
            --text-color: #1F2937;
            --text-light: #4B5563;
            --bg-color: #FFFFFF;
            --bg-secondary: #F9FAFB;
            --border-color: #E5E7EB;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --highlight-bg: #EFF6FF;
            --highlight-border: #DBEAFE;
        }

        .dark {
            --primary-color: #60A5FA;
            --primary-dark: #3B82F6;
            --secondary-color: #34D399;
            --accent-color: #A78BFA;
            --text-color: #F9FAFB;
            --text-light: #E5E7EB;
            --bg-color: #0F172A; /* 更深的背景色 */
            --bg-secondary: #1E293B; /* 更深的次要背景色 */
            --border-color: #475569;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --highlight-bg: #0D2150; /* 更深的高亮背景色 */
            --highlight-border: #3B82F6;
        }
        
        /* 深色模式下的文本颜色增强 */
        .dark .text-gray-600 {
            color: #D1D5DB !important; /* 提高灰色文本在深色背景下的可见度 */
        }
        
        .dark .text-gray-700 {
            color: #E5E7EB !important;
        }
        
        .dark .text-gray-800 {
            color: #F3F4F6 !important;
        }
        
        /* 深色模式下的卡片和背景增强 */
        .dark .card {
            background-color: #1F2937 !important;
            border-color: #374151 !important;
            border: 1px solid #374151 !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5) !important;
        }
        
        /* 安装Python解释器的三个环境模块 */
        .dark .installation-section {
            background-color: #1F2937 !important;
            color: #F8FAFC !important;
            border: 1px solid #374151 !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5) !important;
        }
        
        /* Python开发工具模块 */
        .dark .tools-section {
            background-color: #1F2937 !important;
            color: #F8FAFC !important;
            border: 1px solid #374151 !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5) !important;
        }
        
        .dark #IDLE {
            background-color: #1F2937 !important;
            color: #F8FAFC !important;
            border: 1px solid #374151 !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5) !important;
        }
        
        .dark #IPython, .dark #PyCharm, .dark .practice-section, .dark .windows-section, .dark .linux-section, .dark .macos-section {
            background-color: #1F2937 !important;
            color: #F8FAFC !important;
            border: 1px solid #374151 !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5) !important;
        }
        
        /* 练习模块 */
        .dark .practice-section {
            background-color: var(--bg-secondary);
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            box-shadow: var(--card-shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .dark .practice-section h3, 
        .dark .practice-section h4, 
        .dark .practice-section p, 
        .dark .practice-section li {
            color: #F8FAFC !important;
        }
        
        .dark .practice-section code {
            background-color: #1E293B !important;
            color: #F8FAFC !important;
        }
        
        .dark .practice-section pre {
            background-color: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
        }
        /* 深色模式下的内容区域增强 */
        .dark .module-section {
            background-color: #1F2937 !important;
            border-radius: 0.5rem;
            border: 1px solid #E5E7EB;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .dark .module-section h3, .dark .module-section h4, .dark .module-section p, .dark .module-section li {
            color: #F8FAFC !important;
        }
        
        .dark .text-gray-700 {
            color: #E5E7EB !important;
        }
        
        .dark .text-gray-800 {
            color: #F3F4F6 !important;
        }
        
        /* 深色模式下的卡片和背景增强 */
        .dark .card {
            background-color: var(--bg-color);
            border-radius: 0.5rem;
            box-shadow: var(--card-shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        /* 确保所有深色模式下的文本有足够对比度 */
        .dark p, .dark li, .dark h3, .dark h4, .dark span {
            color: #F8FAFC !important; /* 更亮的文本颜色，提高对比度 */
        }
        
        /* 深色模式下的标题增强 */
        .dark h1, .dark h2 {
            color: #F8FAFC !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        /* 深色模式下的代码块增强 */
        .dark pre {
            background-color: #0D1829 !important;
            border-left: 4px solid #60A5FA !important;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            margin: 1.5rem 0;
            padding: 1.25rem;
        }
        
        .dark code {
            background-color: #1E293B !important;
            color: #F8FAFC !important;
            font-weight: 500;
        }
        
        .dark pre code {
            background-color: transparent !important;
            color: #F8FAFC !important;
            font-weight: normal;
        }
                /* 进度条 */
        .progress-container {
            width: 100%;
            height: 4px;
            background: rgba(0,0,0,0.1);
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
        }
        
        /* 深色模式下的表格增强 */
        .dark table th {
            background-color: #0D1829 !important;
            color: #F8FAFC !important;
            border-color: #374151 !important;
            font-weight: 600;
        }
        
        .dark table td {
            background-color: #1E293B !important;
            border-color: #374151 !important;
            color: #F1F5F9 !important;
        }
        
        .dark table tr:nth-child(odd) td {
            background-color: #172033 !important;
        }
        
        /* 深色模式下的引用和提示框增强 */
        .dark blockquote {
            background-color: #0D1829 !important;
            border-color: #60A5FA !important;
            color: #F8FAFC !important;
            padding: 1.25rem !important;
            border-radius: 0.375rem !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-left: 4px solid #60A5FA !important;
            margin: 1.5rem 0 !important;
        }
        
        /* Hero区域按钮深色模式增强 */
        .dark a.bg-white {
            background-color: #2563EB !important;
            color: #FFFFFF !important;
            border: 1px solid #60A5FA !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            font-weight: 600;
        }
        
        .dark .hover\:bg-blue-50:hover {
            background-color: #1D4ED8 !important;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4) !important;
            color: #FFFFFF !important;
        }
        
        /* 深色模式下的Hero区域增强 */
        .dark .bg-gradient-to-r {
            background: linear-gradient(to right, #1E3A8A, #5B21B6) !important;
            border: 1px solid #2D3748;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        
        /* 深色模式下的导航链接增强 */
        .dark .nav-link {
            color: #E2E8F0 !important;
            transition: all 0.2s ease;
        }
        
        .dark .nav-link:hover {
            color: #7DD3FC !important;
            background-color: #0D1829 !important;
            border-radius: 0.375rem;
            padding-left: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .dark .nav-link.active {
            color: #38BDF8 !important;
            font-weight: 600;
            background-color: #0D1829 !important;
            border-radius: 0.375rem;
            padding: 0.5rem;
            border-left: 3px solid #60A5FA;
        }

        body {
            font-family: 'Noto Sans SC', Tahoma, Arial, Roboto, "Droid Sans", "Helvetica Neue", "Droid Sans Fallback", "Heiti SC", "Hiragino Sans GB", Simsun, sans-serif;
            color: var(--text-color);
            background-color: var(--bg-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* 排版样式 */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Noto Serif SC', serif;
            font-weight: 600;
            line-height: 1.3;
            margin-bottom: 0.75em;
            color: var(--text-color);
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        h2 {
            font-size: 2rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
            margin-top: 2rem;
        }

        h3 {
            font-size: 1.5rem;
            margin-top: 1.5rem;
        }

        h4 {
            font-size: 1.25rem;
            margin-top: 1.25rem;
        }

        p {
            margin-bottom: 1.25rem;
            line-height: 1.7;
        }

        /* 首字下沉效果 */
        .first-letter::first-letter {
            font-size: 3.5em;
            font-weight: 700;
            float: left;
            line-height: 0.8;
            margin-right: 0.1em;
            color: var(--primary-color);
        }

        /* 链接样式 */
        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        a:hover {
            color: var(--primary-dark);
            text-decoration: underline;
        }

        /* 代码样式 */
        pre {
            background-color: var(--bg-secondary);
            border-radius: 0.5rem;
            padding: 1rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            border-left: 4px solid var(--primary-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        code {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            background-color: var(--bg-secondary);
            padding: 0.2em 0.4em;
            border-radius: 0.25rem;
            color: var(--text-color);
        }

        pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit;
            font-size: 1em;
            line-height: 1.6;
        }
        
        /* 复制按钮样式 */
        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0.8;
            transition: all 0.2s ease;
            z-index: 1;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn:active {
            transform: translateY(0);
        }
        
        .dark .copy-btn {
            background-color: var(--primary-color);
            color: white;
        }
        
        .dark .copy-btn:hover {
            background-color: var(--primary-dark);
        }

        /* 表格样式 */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        th, td {
            padding: 0.75rem;
            border: 1px solid var(--border-color);
        }

        th {
            background-color: var(--bg-secondary);
            font-weight: 600;
        }

        /* 引用样式 */
        blockquote {
            border-left: 4px solid var(--accent-color);
            padding-left: 1rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        /* 列表样式 */
        ul, ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        ul {
            list-style-type: disc;
        }

        ol {
            list-style-type: decimal;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }

        /* 卡片样式 */
        .card {
            background-color: var(--bg-color);
            border-radius: 0.5rem;
            box-shadow: var(--card-shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        /* 高亮区域 */
        .highlight {
            background-color: var(--highlight-bg);
            border: 1px solid var(--highlight-border);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        /* 导航样式 */
        .nav-link {
            display: block;
            padding: 0.5rem 0;
            color: var(--text-light);
            transition: color 0.2s ease, transform 0.2s ease;
        }

        .nav-link:hover {
            color: var(--primary-color);
            transform: translateX(5px);
            text-decoration: none;
        }

        .nav-link.active {
            color: var(--primary-color);
            font-weight: 500;
        }

        /* 目录样式 */
        .toc-container {
            position: fixed;
            top: 5rem;
            bottom: 2rem;
            width: 280px;
            overflow-y: auto;
            padding-right: 1rem;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) var(--bg-secondary);
        }

        .toc-container::-webkit-scrollbar {
            width: 6px;
        }

        .toc-container::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .toc-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 3px;
        }

        /* 响应式调整 */
        @media (max-width: 1023px) {
            .toc-container {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: auto;
                width: 100%;
                height: 100%;
                z-index: 50;
                background-color: var(--bg-color);
                padding: 2rem;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }

            .toc-container.show {
                transform: translateX(0);
            }

            .toc-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 40;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s ease;
            }

            .toc-overlay.show {
                opacity: 1;
                pointer-events: auto;
            }
        }

        /* 进度条样式 */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0,0,0,0.1);
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
        }

        /* 主题切换按钮 */
        .theme-toggle {
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease;
        }

        .theme-toggle:hover {
            background-color: var(--bg-secondary);
        }

        /* 动画效果 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .animate-fade-in {
            animation: fadeIn 0.5s ease forwards;
        }

        /* 代码高亮 */
        .token.comment,
        .token.prolog,
        .token.doctype,
        .token.cdata {
            color: #6B7280;
        }

        .token.punctuation {
            color: #6B7280;
        }

        .token.namespace {
            opacity: 0.7;
        }

        .token.property,
        .token.tag,
        .token.boolean,
        .token.number,
        .token.constant,
        .token.symbol {
            color: #EA580C;
        }

        .token.selector,
        .token.attr-name,
        .token.string,
        .token.char,
        .token.builtin {
            color: #059669;
        }

        .token.operator,
        .token.entity,
        .token.url,
        .language-css .token.string,
        .style .token.string {
            color: #9333EA;
        }

        .token.atrule,
        .token.attr-value,
        .token.keyword {
            color: #2563EB;
        }

        .token.function,
        .token.class-name {
            color: #D97706;
        }

        .token.regex,
        .token.important,
        .token.variable {
            color: #EC4899;
        }

        .token.important,
        .token.bold {
            font-weight: bold;
        }

        .token.italic {
            font-style: italic;
        }

        .token.entity {
            cursor: help;
        }

        /* 深色模式代码高亮调整 */
        .dark .token.comment,
        .dark .token.prolog,
        .dark .token.doctype,
        .dark .token.cdata {
            color: #94A3B8; /* 更亮的注释颜色 */
        }

        .dark .token.punctuation {
            color: #E2E8F0; /* 更亮的标点符号 */
        }
        
        /* 深色模式下的页面背景增强 */
        .dark body {
            background-color: #0A1120; /* 更深的页面背景 */
        }
        
        /* 深色模式下的顶部导航栏增强 */
        .dark header {
            background-color: #0D1829 !important;
            border-bottom: 1px solid #1E293B;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .dark .token.property,
        .dark .token.tag,
        .dark .token.boolean,
        .dark .token.number,
        .dark .token.constant,
        .dark .token.symbol {
            color: #FB923C; /* 更亮的属性颜色 */
        }

        .dark .token.selector,
        .dark .token.attr-name,
        .dark .token.string,
        .dark .token.char,
        .dark .token.builtin {
            color: #34D399; /* 更亮的字符串颜色 */
        }

        .dark .token.operator,
        .dark .token.entity,
        .dark .token.url,
        .dark .language-css .token.string,
        .dark .style .token.string {
            color: #C4B5FD; /* 更亮的运算符颜色 */
        }

        .dark .token.atrule,
        .dark .token.attr-value,
        .dark .token.keyword {
            color: #93C5FD; /* 更亮的关键字颜色 */
        }

        .dark .token.function,
        .dark .token.class-name {
            color: #FCD34D; /* 更亮的函数名颜色 */
        }

        .dark .token.regex,
        .dark .token.important,
        .dark .token.variable {
            color: #F9A8D4; /* 更亮的变量颜色 */
        }
        
        /* 深色模式下的卡片内容增强 */
        .dark .card h3, .dark .card h4 {
            color: #BAE6FD !important; /* 更亮的蓝色标题 */
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .dark .card a {
            color: #38BDF8 !important;
            text-decoration: underline;
            font-weight: 500;
        }
        
        .dark .card a:hover {
            color: #7DD3FC !important; /* 更亮的悬停颜色 */
            text-decoration: none;
        }
        
        /* 深色模式下的内容区域增强 */
.dark main section {
    background-color: #0D1829;
    border-radius: 0.5rem;
    padding: 1.25rem;
    margin-bottom: 1.5rem;
    border: 1px solid #1E293B;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

/* 练习模块深色模式样式 */
.dark .bg-gray-50 {
    background-color: #1F2937 !important;
    color: #F8FAFC !important;
}

.dark .bg-gray-50 h4,
.dark .bg-gray-50 p,
.dark .bg-gray-50 li {
    color: #F8FAFC !important;
}

.dark .bg-gray-50 code {
    background-color: #1E293B !important;
    color: #F8FAFC !important;
}

.dark .bg-gray-50 pre {
    background-color: #0D1829 !important;
    border-left: 4px solid #60A5FA !important;
}
        
        /* 深色模式下的内容文本增强 */
        .dark main section p {
            color: #F8FAFC !important;
            line-height: 1.8;
        }
        
        /* 深色模式下的列表项增强 */
        .dark main section li {
            color: #F8FAFC !important;
            margin-bottom: 0.75rem;
        }
        
        /* 深色模式下的内容块增强 */
        .dark .highlight {
            background-color: #0D2150 !important;
            border: 1px solid #1E40AF !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body class="min-h-screen">
    <div class="progress-container no-print">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    <!-- 顶部导航栏 -->
    <header class="sticky top-0 z-30 bg-white dark:bg-gray-900 shadow-md">
        <div class="container mx-auto px-4 py-3 flex items-center justify-between">
            <div class="flex items-center space-x-2">
                <i class="fab fa-python text-3xl text-blue-500"></i>
                <h1 class="text-xl font-bold m-0">Python学习之旅</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="toc-toggle" class="lg:hidden p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors">
                    <i class="fas fa-bars text-gray-600 dark:text-gray-300"></i>
                </button>
                <div class="theme-toggle" id="theme-toggle">
                    <i class="fas fa-sun text-yellow-500 dark:hidden"></i>
                    <i class="fas fa-moon text-blue-300 hidden dark:block"></i>
                </div>
            </div>
        </div>
    </header>

    <!-- 主要内容区域 -->
    <div class="container mx-auto px-4 py-8 flex flex-col lg:flex-row">
        <!-- 目录区域 -->
        <aside class="lg:w-1/4 lg:pr-8">
            <div class="toc-container hidden lg:block">
                <h2 class="text-lg font-bold mb-4 flex items-center">
                    <i class="fas fa-list-ul mr-2 text-blue-500"></i>目录
                </h2>
                <nav id="toc" class="space-y-1">
                    <!-- 目录内容将通过JavaScript动态生成 -->
                </nav>
            </div>
        </aside>

        <!-- 移动端目录覆盖层 -->
        <div class="toc-overlay" id="toc-overlay"></div>
        <div class="toc-container lg:hidden" id="mobile-toc">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold flex items-center">
                    <i class="fas fa-list-ul mr-2 text-blue-500"></i>目录
                </h2>
                <button id="close-toc" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800">
                    <i class="fas fa-times text-gray-600 dark:text-gray-300"></i>
                </button>
            </div>
            <nav class="space-y-1">
                <!-- 移动端目录内容将通过JavaScript动态复制 -->
            </nav>
        </div>

                <!-- 内容区域 -->
                <main class="lg:w-3/4 animate-fade-in" id="content">
                   <!-- Hero 区域 -->
                   <section class="mb-12 relative overflow-hidden rounded-xl">
                    <div class="bg-gradient-to-r from-blue-500 to-purple-600 text-white p-8 md:p-12 rounded-xl shadow-lg">
                        <div class="relative z-10">
                            <h1 class="text-3xl md:text-4xl lg:text-5xl font-bold mb-4">Python语言进阶</h1>
                            <p class="text-xl md:text-2xl font-light mb-6 max-w-3xl">掌握Python高级特性，提升编程技能，成为Python专家</p>
                            <div class="flex flex-wrap gap-4">
                                <a href="#section-1" class="bg-white text-blue-600 hover:bg-blue-50 px-6 py-3 rounded-lg font-medium transition-colors shadow-md hover:shadow-lg flex items-center">
                                    <i class="fas fa-star mr-2"></i>重要知识点
                                </a>
                                <a href="#section-2" class="bg-transparent border-2 border-white hover:bg-white hover:text-blue-600 px-6 py-3 rounded-lg font-medium transition-colors flex items-center">
                                    <i class="fas fa-code-branch mr-2"></i>数据结构和算法
                                </a>
                                <a href="#section-3" class="bg-transparent border-2 border-white hover:bg-white hover:text-blue-600 px-6 py-3 rounded-lg font-medium transition-colors flex items-center">
                                    <i class="fas fa-functions mr-2"></i>函数的使用方式
                                </a>
                                <a href="#section-4" class="bg-transparent border-2 border-white hover:bg-white hover:text-blue-600 px-6 py-3 rounded-lg font-medium transition-colors flex items-center">
                                    <i class="fas fa-object-group mr-2"></i>面向对象
                                </a>
                                <a href="#section-5" class="bg-transparent border-2 border-white hover:bg-white hover:text-blue-600 px-6 py-3 rounded-lg font-medium transition-colors flex items-center">
                                    <i class="fas fa-sync-alt mr-2"></i>迭代器和生成器
                                </a>
                                <a href="#section-6" class="bg-transparent border-2 border-white hover:bg-white hover:text-blue-600 px-6 py-3 rounded-lg font-medium transition-colors flex items-center">
                                    <i class="fas fa-network-wired mr-2"></i>并发编程
                                </a>
                            </div>
                        </div>
                        <!-- 装饰性元素 -->
                        <div class="absolute right-0 top-0 h-full w-1/3 opacity-20">
                            <div class="absolute right-0 top-1/4 transform rotate-45">
                                <i class="fab fa-python text-9xl"></i>
                            </div>
                            <div class="absolute right-20 bottom-1/4 transform -rotate-12">
                                <i class="fas fa-terminal text-7xl"></i>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- 1. 重要知识点 -->
                <section id="section-1" class="content-section p-6 mb-8">
                    <h2 class="section-title text-2xl font-bold">
                        <i class="fas fa-star"></i>
                        重要知识点
                    </h2>
                    <div class="space-y-6">
                        <!-- 生成式（推导式）的用法 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">生成式（推导式）的用法</h3>
                            <p>生成式（推导式）可以用来生成列表、集合和字典，是Python中非常优雅和高效的语法特性。</p>
                            <pre><code class="language-python">prices = {
    'AAPL': 191.88,
    'GOOG': 1186.96,
    'IBM': 149.24,
    'ORCL': 48.44,
    'ACN': 166.89,
    'FB': 208.09,
    'SYMC': 21.29
}
# 用股票价格大于100元的股票构造一个新的字典
prices2 = {key: value for key, value in prices.items() if value > 100}
print(prices2)</code><button class="copy-btn">复制</button></pre>
                            <blockquote>
                                <p><strong>说明</strong>：生成式（推导式）可以用来生成列表、集合和字典。</p>
                            </blockquote>
                        </div>

                        <!-- 嵌套的列表的坑 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">嵌套的列表的坑</h3>
                            <p>在创建嵌套列表时要特别注意引用的问题，错误的方式会导致所有子列表引用同一个对象。</p>
                            <pre><code class="language-python">names = ['关羽', '张飞', '赵云', '马超', '黄忠']
courses = ['语文', '数学', '英语']
# 录入五个学生三门课程的成绩
# 错误 - 参考http://pythontutor.com/visualize.html#mode=edit
# scores = [[None] * len(courses)] * len(names)
scores = [[None] * len(courses) for _ in range(len(names))]
for row, name in enumerate(names):
    for col, course in enumerate(courses):
        scores[row][col] = float(input(f'请输入{name}的{course}成绩: '))
        print(scores)</code><button class="copy-btn">复制</button></pre>
                            <blockquote>
                                <p><strong>说明</strong>：<a href="http://pythontutor.com/" target="_blank">Python Tutor</a> 是一个很好的可视化代码执行过程的工具。</p>
                            </blockquote>
                        </div>

                        <!-- heapq模块 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">`heapq`模块（堆排序）</h3>
                            <p>`heapq`模块提供了堆数据结构的实现，可以高效地找出最大或最小的N个元素。</p>
                            <pre><code class="language-python">"""
从列表中找出最大的或最小的N个元素
堆结构(大根堆/小根堆)
"""
import heapq

list1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]
list2 = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
print(heapq.nlargest(3, list1))
print(heapq.nsmallest(3, list1))
print(heapq.nlargest(2, list2, key=lambda x: x['price']))
print(heapq.nlargest(2, list2, key=lambda x: x['shares']))</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- itertools模块 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">`itertools`模块</h3>
                            <p>`itertools`模块提供了创建迭代器的函数，这些工具用于处理和生成复杂的迭代模式。</p>
                            <pre><code class="language-python">"""
迭代工具模块
"""
import itertools

# 产生ABCD的全排列
itertools.permutations('ABCD')
# 产生ABCDE的五选三组合
itertools.combinations('ABCDE', 3)
# 产生ABCD和123的笛卡尔积
itertools.product('ABCD', '123')
# 产生ABC的无限循环序列
itertools.cycle(('A', 'B', 'C'))</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- collections模块 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">`collections`模块</h3>
                            <p>`collections`模块提供了许多有用的容器数据类型，可以替代内置的容器类型或提供额外的功能。</p>
                            
                            <h4 class="text-lg font-semibold mt-4 mb-2">常用的工具类：</h4>
                            <ul class="list-disc pl-6 space-y-2">
                                <li><strong>namedtuple</strong>：命名元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。</li>
                                <li><strong>deque</strong>：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而deque底层是双向链表，因此当你需要在头尾添加和删除元素时，deque会表现出更好的性能，渐近时间复杂度为O(1)。</li>
                                <li><strong>Counter</strong>：`dict`的子类，键是元素，值是元素的计数，它的most_common()方法可以帮助我们获取出现频率最高的元素。`Counter`和`dict`的继承关系我认为是值得商榷的，按照CARP原则，`Counter`跟`dict`的关系应该设计为关联关系更为合理。</li>
                                <li><strong>OrderedDict</strong>：`dict`的子类，它记录了键值对插入的顺序。</li>
                                <li><strong>defaultdict</strong>：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值。相比字典中的`setdefault()`方法，这种做法更加高效。</li>
                            </ul>

                            <h4 class="text-lg font-semibold mt-4 mb-2">示例：找出序列中出现次数最多的元素</h4>
                            <pre><code class="language-python">"""
找出序列中出现次数最多的元素
"""
from collections import Counter

words = [
    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around',
    'the', 'eyes', "don't", 'look', 'around', 'the', 'eyes',
    'look', 'into', 'my', 'eyes', "you're", 'under'
]
counter = Counter(words)
print(counter.most_common(3))</code><button class="copy-btn">复制</button></pre>
                        </div>
                    </div>
                </section>

                <!-- 2. 数据结构和算法 -->
                <section id="section-2" class="content-section p-6 mb-8">
                    <h2 class="section-title text-2xl font-bold">
                        <i class="fas fa-code-branch"></i>
                        数据结构和算法
                    </h2>
                    <div class="space-y-6">
                        <!-- 算法基础 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">算法基础</h3>
                            <p><strong>算法</strong>：解决问题的方法和步骤</p>
                            <p><strong>评价算法的好坏</strong>：渐近时间复杂度和渐近空间复杂度</p>
                        </div>

                        <!-- 时间复杂度 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">渐近时间复杂度的大O标记</h3>
                            <div class="overflow-x-auto">
                                <table class="w-full border-collapse border border-gray-300">
                                    <thead>
                                        <tr class="bg-gray-100 dark:bg-gray-800">
                                            <th class="border border-gray-300 px-4 py-2">复杂度</th>
                                            <th class="border border-gray-300 px-4 py-2">名称</th>
                                            <th class="border border-gray-300 px-4 py-2">典型算法</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td class="border border-gray-300 px-4 py-2">O(1)</td>
                                            <td class="border border-gray-300 px-4 py-2">常量时间复杂度</td>
                                            <td class="border border-gray-300 px-4 py-2">布隆过滤器 / 哈希存储</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-gray-300 px-4 py-2">O(log₂n)</td>
                                            <td class="border border-gray-300 px-4 py-2">对数时间复杂度</td>
                                            <td class="border border-gray-300 px-4 py-2">折半查找（二分查找）</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-gray-300 px-4 py-2">O(n)</td>
                                            <td class="border border-gray-300 px-4 py-2">线性时间复杂度</td>
                                            <td class="border border-gray-300 px-4 py-2">顺序查找 / 计数排序</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-gray-300 px-4 py-2">O(n*log₂n)</td>
                                            <td class="border border-gray-300 px-4 py-2">对数线性时间复杂度</td>
                                            <td class="border border-gray-300 px-4 py-2">高级排序算法（归并排序、快速排序）</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-gray-300 px-4 py-2">O(n²)</td>
                                            <td class="border border-gray-300 px-4 py-2">平方时间复杂度</td>
                                            <td class="border border-gray-300 px-4 py-2">简单排序算法（选择排序、插入排序、冒泡排序）</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-gray-300 px-4 py-2">O(n³)</td>
                                            <td class="border border-gray-300 px-4 py-2">立方时间复杂度</td>
                                            <td class="border border-gray-300 px-4 py-2">Floyd算法 / 矩阵乘法运算</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-gray-300 px-4 py-2">O(2ⁿ)</td>
                                            <td class="border border-gray-300 px-4 py-2">几何级数时间复杂度</td>
                                            <td class="border border-gray-300 px-4 py-2">汉诺塔</td>
                                        </tr>
                                        <tr>
                                            <td class="border border-gray-300 px-4 py-2">O(n!)</td>
                                            <td class="border border-gray-300 px-4 py-2">阶乘时间复杂度</td>
                                            <td class="border border-gray-300 px-4 py-2">旅行经销商问题 - NPC</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- 排序算法 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">排序算法</h3>
                            
                            <h4 class="text-lg font-semibold mt-4 mb-2">简单选择排序</h4>
                            <pre><code class="language-python">def select_sort(items, comp=lambda x, y: x < y):
    """简单选择排序"""
    items = items[:]
    for i in range(len(items) - 1):
        min_index = i
        for j in range(i + 1, len(items)):
            if comp(items[j], items[min_index]):
                min_index = j
        items[i], items[min_index] = items[min_index], items[i]
    return items</code><button class="copy-btn">复制</button></pre>

                            <h4 class="text-lg font-semibold mt-4 mb-2">冒泡排序</h4>
                            <pre><code class="language-python">def bubble_sort(items, comp=lambda x, y: x > y):
    """冒泡排序"""
    items = items[:]
    for i in range(len(items) - 1):
        swapped = False
        for j in range(len(items) - 1 - i):
            if comp(items[j], items[j + 1]):
                items[j], items[j + 1] = items[j + 1], items[j]
                swapped = True
        if not swapped:
            break
    return items</code><button class="copy-btn">复制</button></pre>

                            <h4 class="text-lg font-semibold mt-4 mb-2">归并排序</h4>
                            <pre><code class="language-python">def merge(items1, items2, comp=lambda x, y: x < y):
    """合并(将两个有序的列表合并成一个有序的列表)"""
    items = []
    index1, index2 = 0, 0
    while index1 < len(items1) and index2 < len(items2):
        if comp(items1[index1], items2[index2]):
            items.append(items1[index1])
            index1 += 1
        else:
            items.append(items2[index2])
            index2 += 1
    items += items1[index1:]
    items += items2[index2:]
    return items

def merge_sort(items, comp=lambda x, y: x < y):
    return _merge_sort(list(items), comp)

def _merge_sort(items, comp):
    """归并排序"""
    if len(items) < 2:
        return items
    mid = len(items) // 2
    left = _merge_sort(items[:mid], comp)
    right = _merge_sort(items[mid:], comp)
    return merge(left, right, comp)</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- 查找算法 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">查找算法</h3>
                            
                            <h4 class="text-lg font-semibold mt-4 mb-2">顺序查找</h4>
                            <pre><code class="language-python">def seq_search(items, key):
    """顺序查找"""
    for index, item in enumerate(items):
        if item == key:
            return index
    return -1</code><button class="copy-btn">复制</button></pre>

                            <h4 class="text-lg font-semibold mt-4 mb-2">折半查找（二分查找）</h4>
                            <pre><code class="language-python">def bin_search(items, key):
    """折半查找"""
    start, end = 0, len(items) - 1
    while start <= end:
        mid = (start + end) // 2
        if key > items[mid]:
            start = mid + 1
        elif key < items[mid]:
            end = mid - 1
        else:
            return mid
    return -1</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- 常用算法 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">常用算法</h3>
                            <ul class="list-disc pl-6 space-y-2">
                                <li><strong>穷举法</strong> - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。</li>
                                <li><strong>贪婪法</strong> - 在对问题求解时，总是做出在当前看来最好的选择，不追求最优解，快速找到满意解。</li>
                                <li><strong>分治法</strong> - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。</li>
                                <li><strong>回溯法</strong> - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。</li>
                                <li><strong>动态规划</strong> - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。</li>
                            </ul>

                            <h4 class="text-lg font-semibold mt-4 mb-2">穷举法例子：百钱百鸡和五人分鱼</h4>
                            <pre><code class="language-python"># 公鸡5元一只 母鸡3元一只 小鸡1元三只
  # 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只
  for x in range(20):
      for y in range(33):
          z = 100 - x - y
          if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:
              print(x, y, z)
  
  # A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉
  # 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份
  # B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份
  # 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼
  fish = 6
  while True:
      total = fish
      enough = True
      for _ in range(5):
          if (total - 1) % 5 == 0:
              total = (total - 1) // 5 * 4
          else:
              enough = False
              break
      if enough:
          print(fish)
          break
      fish += 5</code><button class="copy-btn">复制</button></pre>

<h4 class="text-lg font-semibold mt-4 mb-2"> 贪婪法例子</h4>
<p>假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。</p>
<p>  |  名称  | 价格（美元） | 重量（kg） | </p>
<p>  | :----: | :----------: | :--------: | </p>
<p>  |  电脑  |     200      |     20     | </p>
<p>  | 收音机 |      20      |     4      | </p>
<p>  |   钟   |     175      |     10     | </p>
<p>  |  花瓶  |      50      |     2      | </p>
<p>  |   书   |      10      |     1      | </p>
<p>  |  油画  |      90      |     9      | </p>

                            <pre><code class="language-python">  """
  贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。
  输入：
  20 6
  电脑 200 20
  收音机 20 4
  钟 175 10
  花瓶 50 2
  书 10 1
  油画 90 9
  """
  class Thing(object):
      """物品"""
  
      def __init__(self, name, price, weight):
          self.name = name
          self.price = price
          self.weight = weight
  
      @property
      def value(self):
          """价格重量比"""
          return self.price / self.weight
  
  
  def input_thing():
      """输入物品信息"""
      name_str, price_str, weight_str = input().split()
      return name_str, int(price_str), int(weight_str)
  
  
  def main():
      """主函数"""
      max_weight, num_of_things = map(int, input().split())
      all_things = []
      for _ in range(num_of_things):
          all_things.append(Thing(*input_thing()))
      all_things.sort(key=lambda x: x.value, reverse=True)
      total_weight = 0
      total_price = 0
      for thing in all_things:
          if total_weight + thing.weight <= max_weight:
              print(f'小偷拿走了{thing.name}')
              total_weight += thing.weight
              total_price += thing.price
      print(f'总价值: {total_price}美元')
  
  
  if __name__ == '__main__':
      main()</code><button class="copy-btn">复制</button></pre>


      <h4 class="text-lg font-semibold mt-4 mb-2">分治法例子：[快速排序]。</h4>
      <pre><code class="language-python">  """
  快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大
  """
  def quick_sort(items, comp=lambda x, y: x <= y):
      items = list(items)[:]
      _quick_sort(items, 0, len(items) - 1, comp)
      return items
  
  
  def _quick_sort(items, start, end, comp):
      if start < end:
          pos = _partition(items, start, end, comp)
          _quick_sort(items, start, pos - 1, comp)
          _quick_sort(items, pos + 1, end, comp)
  
  
  def _partition(items, start, end, comp):
      pivot = items[end]
      i = start - 1
      for j in range(start, end):
          if comp(items[j], pivot):
              i += 1
              items[i], items[j] = items[j], items[i]
      items[i + 1], items[end] = items[end], items[i + 1]
      return i + 1</code><button class="copy-btn">复制</button></pre>


      <h4 class="text-lg font-semibold mt-4 mb-2">  回溯法例子：[骑士巡逻]。</h4>
                            <pre><code class="language-python">  """
  递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。
  """
  import sys
  import time
  
  SIZE = 5
  total = 0
  
  
  def print_board(board):
      for row in board:
          for col in row:
              print(str(col).center(4), end='')
          print()
  
  
  def patrol(board, row, col, step=1):
      if row >= 0 and row < SIZE and \
          col >= 0 and col < SIZE and \
          board[row][col] == 0:
          board[row][col] = step
          if step == SIZE * SIZE:
              global total
              total += 1
              print(f'第{total}种走法: ')
              print_board(board)
          patrol(board, row - 2, col - 1, step + 1)
          patrol(board, row - 1, col - 2, step + 1)
          patrol(board, row + 1, col - 2, step + 1)
          patrol(board, row + 2, col - 1, step + 1)
          patrol(board, row + 2, col + 1, step + 1)
          patrol(board, row + 1, col + 2, step + 1)
          patrol(board, row - 1, col + 2, step + 1)
          patrol(board, row - 2, col + 1, step + 1)
          board[row][col] = 0
  
  
  def main():
      board = [[0] * SIZE for _ in range(SIZE)]
      patrol(board, SIZE - 1, SIZE - 1)
  
  
  if __name__ == '__main__':
      main()</code><button class="copy-btn">复制</button></pre>



                            <h4 class="text-lg font-semibold mt-4 mb-2">动态规划例子：子列表元素之和的最大值</h4>
                            <p>子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：</p>
                            <p>  > 输入：1 -2 3 5 -3 2</p>
                            <p>  > 输出：8</p>
                            <p>  > 输入：0 -2 3 5 -1 2</p>
                            <p>  > 输出：9</p>
                            <p>  > 输入：-9 -2 -3 -5 -3</p>
                            <p>  > 输出：-2</p>
                            <pre><code class="language-python">def main():
    items = list(map(int, input().split()))
    overall = partial = items[0]
    for i in range(1, len(items)):
        partial = max(items[i], partial + items[i])
        overall = max(partial, overall)
    print(overall)</code><button class="copy-btn">复制</button></pre>
                            <blockquote>
                                <p><strong>说明</strong>：这个题目最容易想到的解法是使用二重循环，但是代码的时间性能将会变得非常的糟糕。使用动态规划的思想，仅仅是多用了两个变量，就将原来O(N²)复杂度的问题变成了O(N)。</p>
                            </blockquote>
                        </div>
                    </div>
                </section>

                <!-- 3. 函数的使用方式 -->
                <section id="section-3" class="content-section p-6 mb-8">
                    <h2 class="section-title text-2xl font-bold">
                        <i class="fas fa-functions"></i>
                        函数的使用方式
                    </h2>
                    <div class="space-y-6">
                        <!-- 函数作为一等公民 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">将函数视为"一等公民"</h3>
                            <ul class="list-disc pl-6 space-y-2">
                                <li>函数可以赋值给变量</li>
                                <li>函数可以作为函数的参数</li>
                                <li>函数可以作为函数的返回值</li>
                            </ul>
                        </div>

                        <!-- 高阶函数 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">高阶函数的用法（`filter`、`map`以及它们的替代品）</h3>
                            <pre><code class="language-python">items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10))))
items2 = [x ** 2 for x in range(1, 10) if x % 2]</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- 参数类型 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">参数类型</h3>
                            <ul class="list-disc pl-6 space-y-2">
                                <li>位置参数、可变参数、关键字参数、命名关键字参数</li>
                                <li>参数的元信息（代码可读性问题）</li>
                                <li>匿名函数和内联函数的用法（`lambda`函数）</li>
                            </ul>
                        </div>

                        <!-- 闭包和作用域 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">闭包和作用域问题</h3>
                            <ul class="list-disc pl-6 space-y-2">
                                <li>Python搜索变量的LEGB顺序（Local >>> Embedded >>> Global >>> Built-in）</li>
                                <li>
                                    <code>global</code>和<code>nonlocal</code>关键字的作用
                                    <p class="mt-2">
                                        <code>global</code>：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。
                                    </p>
                                    <p class="mt-2">
                                        <code>nonlocal</code>：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。
                                    </p>
                                </li>
                            </ul>
                        </div>

                        <!-- 装饰器函数 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">装饰器函数（使用装饰器和取消装饰器）</h3>
                            <p>例子：输出函数执行时间的装饰器。</p>
                            <pre><code class="language-python">def record_time(func):
    """自定义装饰函数的装饰器"""
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time()
        result = func(*args, **kwargs)
        print(f'{func.__name__}: {time() - start}秒')
        return result
        
    return wrapper</code><button class="copy-btn">复制</button></pre>

                            <h4 class="text-lg font-semibold mt-4 mb-2">可以参数化的装饰器</h4>
                            <pre><code class="language-python">from functools import wraps
from time import time

def record(output):
    """可以参数化的装饰器"""
    
    def decorate(func):
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            start = time()
            result = func(*args, **kwargs)
            output(func.__name__, time() - start)
            return result
            
        return wrapper
    
    return decorate</code><button class="copy-btn">复制</button></pre>

                            <h4 class="text-lg font-semibold mt-4 mb-2">通过定义类的方式定义装饰器</h4>
                            <pre><code class="language-python">from functools import wraps
from time import time

class Record():
    """通过定义类的方式定义装饰器"""

    def __init__(self, output):
        self.output = output

    def __call__(self, func):

        @wraps(func)
        def wrapper(*args, **kwargs):
            start = time()
            result = func(*args, **kwargs)
            self.output(func.__name__, time() - start)
            return result

        return wrapper</code><button class="copy-btn">复制</button></pre>

                            <blockquote>
                                <p><strong>说明</strong>：由于对带装饰功能的函数添加了@wraps装饰器，可以通过<code>func.__wrapped__</code>方式获得被装饰之前的函数或类来取消装饰器的作用。</p>
                            </blockquote>

                            <h4 class="text-lg font-semibold mt-4 mb-2">用装饰器来实现单例模式</h4>
                            <pre><code class="language-python">from functools import wraps

def singleton(cls):
    """装饰类的装饰器"""
    instances = {}

    @wraps(cls)
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return wrapper

@singleton
class President:
    """总统(单例类)"""
    pass</code><button class="copy-btn">复制</button></pre>

                            <h4 class="text-lg font-semibold mt-4 mb-2">线程安全的单例装饰器</h4>
                            <pre><code class="language-python">from functools import wraps
from threading import RLock

def singleton(cls):
    """线程安全的单例装饰器"""
    instances = {}
    locker = RLock()

    @wraps(cls)
    def wrapper(*args, **kwargs):
        if cls not in instances:
            with locker:
                if cls not in instances:
                    instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return wrapper</code><button class="copy-btn">复制</button></pre>
                            <blockquote>
                                <p><strong>提示</strong>：上面的代码用到了<code>with</code>上下文语法来进行锁操作，因为锁对象本身就是上下文管理器对象（支持<code>__enter__</code>和<code>__exit__</code>魔术方法）。在<code>wrapper</code>函数中，我们先做了一次不带锁的检查，然后再做带锁的检查，这样做比直接加锁检查性能要更好，如果对象已经创建就没有必须再去加锁而是直接返回该对象就可以了。</p>
                            </blockquote>
                        </div>
                    </div>
                </section>

                <!-- 4. 面向对象相关知识 -->
                <section id="section-4" class="content-section p-6 mb-8">
                    <h2 class="section-title text-2xl font-bold">
                        <i class="fas fa-object-group"></i>
                        面向对象相关知识
                    </h2>
                    <div class="space-y-6">
                        <!-- 三大支柱 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">三大支柱：封装、继承、多态</h3>
                            <p>面向对象编程的三大核心特性：</p>
                            <ul class="list-disc pl-6 space-y-2 mt-2">
                                <li><strong>封装</strong>：将数据和操作数据的方法绑定在一起，隐藏内部实现细节</li>
                                <li><strong>继承</strong>：子类可以继承父类的属性和方法，实现代码复用</li>
                                <li><strong>多态</strong>：同一接口可以有不同的实现方式</li>
                            </ul>

                            <h4 class="text-lg font-semibold mt-4 mb-2">例子：工资结算系统</h4>
                            <pre><code class="language-python">  """
  月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成
  """
  from abc import ABCMeta, abstractmethod
  
  
  class Employee(metaclass=ABCMeta):
      """员工(抽象类)"""
  
      def __init__(self, name):
          self.name = name
  
      @abstractmethod
      def get_salary(self):
          """结算月薪(抽象方法)"""
          pass
  
  
  class Manager(Employee):
      """部门经理"""
  
      def get_salary(self):
          return 15000.0
  
  
  class Programmer(Employee):
      """程序员"""
  
      def __init__(self, name, working_hour=0):
          self.working_hour = working_hour
          super().__init__(name)
  
      def get_salary(self):
          return 200.0 * self.working_hour
  
  
  class Salesman(Employee):
      """销售员"""
  
      def __init__(self, name, sales=0.0):
          self.sales = sales
          super().__init__(name)
  
      def get_salary(self):
          return 1800.0 + self.sales * 0.05
  
  
  class EmployeeFactory:
      """创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）"""
  
      @staticmethod
      def create(emp_type, *args, **kwargs):
          """创建员工"""
          all_emp_types = {'M': Manager, 'P': Programmer, 'S': Salesman}
          cls = all_emp_types[emp_type.upper()]
          return cls(*args, **kwargs) if cls else None
  
  
  def main():
      """主函数"""
      emps = [
          EmployeeFactory.create('M', '曹操'), 
          EmployeeFactory.create('P', '荀彧', 120),
          EmployeeFactory.create('P', '郭嘉', 85), 
          EmployeeFactory.create('S', '典韦', 123000),
      ]
      for emp in emps:
          print(f'{emp.name}: {emp.get_salary():.2f}元')
  
  
  if __name__ == '__main__':
      main()</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- 类与类之间的关系 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">类与类之间的关系</h3>
                            <ul class="list-disc pl-6 space-y-2">
                                <li><strong>is-a关系</strong>：继承</li>
                                <li><strong>has-a关系</strong>：关联 / 聚合 / 合成</li>
                                <li><strong>use-a关系</strong>：依赖</li>
                            </ul>

                            <h4 class="text-lg font-semibold mt-4 mb-2">例子：扑克游戏</h4>
                            <pre><code class="language-python">  """
  经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择
  """
  from enum import Enum, unique
  
  import random
  
  
  @unique
  class Suite(Enum):
      """花色"""
  
      SPADE, HEART, CLUB, DIAMOND = range(4)
  
      def __lt__(self, other):
          return self.value < other.value
  
  
  class Card():
      """牌"""
  
      def __init__(self, suite, face):
          """初始化方法"""
          self.suite = suite
          self.face = face
  
      def show(self):
          """显示牌面"""
          suites = ['♠︎', '♥︎', '♣︎', '♦︎']
          faces = ['', 'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
          return f'{suites[self.suite.value]}{faces[self.face]}'
  
      def __repr__(self):
          return self.show()
  
  
  class Poker():
      """扑克"""
  
      def __init__(self):
          self.index = 0
          self.cards = [Card(suite, face)
                        for suite in Suite
                        for face in range(1, 14)]
  
      def shuffle(self):
          """洗牌（随机乱序）"""
          random.shuffle(self.cards)
          self.index = 0
  
      def deal(self):
          """发牌"""
          card = self.cards[self.index]
          self.index += 1
          return card
  
      @property
      def has_more(self):
          return self.index < len(self.cards)
  
  
  class Player():
      """玩家"""
  
      def __init__(self, name):
          self.name = name
          self.cards = []
  
      def get_one(self, card):
          """摸一张牌"""
          self.cards.append(card)
  
      def sort(self, comp=lambda card: (card.suite, card.face)):
          """整理手上的牌"""
          self.cards.sort(key=comp)
  
  
  def main():
      """主函数"""
      poker = Poker()
      poker.shuffle()
      players = [Player('东邪'), Player('西毒'), Player('南帝'), Player('北丐')]
      while poker.has_more:
          for player in players:
                  player.get_one(poker.deal())
      for player in players:
          player.sort()
          print(player.name, end=': ')
          print(player.cards)
  
  
  if __name__ == '__main__':
      main()</code><button class="copy-btn">复制</button></pre>
      <blockquote>
        <p><strong>提示</strong>：上面的代码中使用了Emoji字符来表示扑克牌的四种花色，在某些不支持Emoji字符的系统上可能无法显示。        </p>
    </blockquote>
                        </div>

                        <!-- 垃圾回收、循环引用和弱引用 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">垃圾回收、循环引用和弱引用</h3>
                            <p>Python使用了自动化内存管理，这种管理机制以<strong>引用计数</strong>为基础，同时也引入了<strong>标记-清除</strong>和<strong>分代收集</strong>两种机制为辅的策略。</p>

                            <pre><code class="language-c">typedef struct _object {
    /* 引用计数 */
    int ob_refcnt;
    /* 对象指针 */
    struct _typeobject *ob_type;
} PyObject;</code><button class="copy-btn">复制</button></pre>
                            <pre><code class="language-c">  /* 增加引用计数的宏定义 */
  #define Py_INCREF(op)   ((op)->ob_refcnt++)
  /* 减少引用计数的宏定义 */
  #define Py_DECREF(op) \ //减少计数
      if (--(op)->ob_refcnt != 0) \
          ; \
      else \
          __Py_Dealloc((PyObject *)(op))</code><button class="copy-btn">复制</button></pre>

                            <h4 class="text-lg font-semibold mt-4 mb-2">导致引用计数+1的情况：</h4>
                            <ul class="list-disc pl-6 space-y-2">
                                <li>对象被创建，例如<code>a = 23</code></li>
                                <li>对象被引用，例如<code>b = a</code></li>
                                <li>对象被作为参数，传入到一个函数中，例如<code>f(a)</code></li>
                                <li>对象作为一个元素，存储在容器中，例如<code>list1 = [a, a]</code></li>
                            </ul>

                            <h4 class="text-lg font-semibold mt-4 mb-2">循环引用示例：</h4>
                            <pre><code class="language-python"># 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收
# 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效
# 如果不想造成循环引用可以使用弱引用
list1 = []
list2 = [] 
list1.append(list2)
list2.append(list1)</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- 魔法属性和方法 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">魔法属性和方法</h3>
                            <p>Python中的魔法方法（特殊方法）让我们可以定义对象的特殊行为：</p>
                            <ul class="list-disc pl-6 space-y-2 mt-2">
                                <li>自定义的对象能不能使用运算符做运算？</li>
                                <li>自定义的对象能不能放到<code>set</code>中？能去重吗？</li>
                                <li>自定义的对象能不能作为<code>dict</code>的键？</li>
                                <li>自定义的对象能不能使用上下文语法？</li>
                            </ul>
                            <p class="mt-2">这些都可以通过实现相应的魔法方法来实现，如<code>__add__</code>、<code>__hash__</code>、<code>__enter__</code>、<code>__exit__</code>等。</p>
                        </div>

                        <!-- 混入（Mixin） -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">混入（Mixin）</h3>
                            <p>混入是一种设计模式，允许将功能"混入"到类中，而不需要使用传统的继承。</p>
                            
                            <h4 class="text-lg font-semibold mt-4 mb-2">例子：自定义字典限制只有在指定的key不存在时才能设置键值对</h4>
                            <pre><code class="language-python">class SetOnceMappingMixin:
    """自定义混入类"""
    __slots__ = ()
    
    def __setitem__(self, key, value):
        if key in self:
            raise KeyError(str(key) + ' already set')
        return super().__setitem__(key, value)

class SetOnceDict(SetOnceMappingMixin, dict):
    """自定义字典"""
    pass

my_dict = SetOnceDict()
try:
    my_dict['username'] = 'jackfrued'
    my_dict['username'] = 'hellokitty'  # 这里会抛出KeyError
except KeyError:
    pass
print(my_dict)</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- 元编程和元类 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">元编程和元类</h3>
                            <p>对象是通过类创建的，类是通过元类创建的，元类提供了创建类的元信息。所有的类都直接或间接的继承自<code>object</code>，所有的元类都直接或间接的继承自<code>type</code>。</p>
                            
                            <h4 class="text-lg font-semibold mt-4 mb-2">例子：用元类实现单例模式</h4>
                            <pre><code class="language-python">import threading

class SingletonMeta(type):
    """自定义元类"""

    def __init__(cls, *args, **kwargs):
        cls.__instance = None
        cls.__lock = threading.RLock()
        super().__init__(*args, **kwargs)

    def __call__(cls, *args, **kwargs):
        if cls.__instance is None:
            with cls.__lock:
                if cls.__instance is None:
                    cls.__instance = super().__call__(*args, **kwargs)
        return cls.__instance

class President(metaclass=SingletonMeta):
    """总统(单例类)"""
    pass</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- 面向对象设计原则 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">面向对象设计原则</h3>
                            <ul class="list-disc pl-6 space-y-2">
                                <li>单一职责原则 （<strong>S</strong>RP）- 一个类只做该做的事情（类的设计要高内聚）</li>
                                <li>开闭原则 （<strong>O</strong>CP）- 软件实体应该对扩展开发对修改关闭</li>
                                <li>依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化）</li>
                                <li>里氏替换原则（<strong>L</strong>SP） - 任何时候可以用子类对象替换掉父类对象</li>
                                <li>接口隔离原则（<strong>I</strong>SP）- 接口要小而专不要大而全（Python中没有接口的概念）</li>
                                <li>合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码</li>
                                <li>最少知识原则（迪米特法则，Lo<strong>D</strong>）- 不要给没有必然联系的对象发消息</li>
                            </ul>
                            <blockquote>
                                <p><strong>说明</strong>：上面加粗的字母放在一起称为面向对象的<strong>SOLID</strong>原则。</p>
                            </blockquote>
                        </div>

                        <!-- GoF设计模式 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">GoF设计模式</h3>
                            <ul class="list-disc pl-6 space-y-2">
                                <li><strong>创建型模式</strong>：单例、工厂、建造者、原型</li>
                                <li><strong>结构型模式</strong>：适配器、门面（外观）、代理</li>
                                <li><strong>行为型模式</strong>：迭代器、观察者、状态、策略</li>
                            </ul>

                            <h4 class="text-lg font-semibold mt-4 mb-2">例子：可插拔的哈希算法（策略模式）</h4>
                            <pre><code class="language-python">  class StreamHasher():
      """哈希摘要生成器"""
  
      def __init__(self, alg='md5', size=4096):
          self.size = size
          alg = alg.lower()
          self.hasher = getattr(__import__('hashlib'), alg.lower())()
  
      def __call__(self, stream):
          return self.to_digest(stream)
  
      def to_digest(self, stream):
          """生成十六进制形式的摘要"""
          for buf in iter(lambda: stream.read(self.size), b''):
              self.hasher.update(buf)
          return self.hasher.hexdigest()
  
  def main():
      """主函数"""
      hasher1 = StreamHasher()
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher1.to_digest(stream))
      hasher2 = StreamHasher('sha1')
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher2(stream))
  
  
  if __name__ == '__main__':
      main()</code><button class="copy-btn">复制</button></pre>
                        </div>
                    </div>
                </section>

                <!-- 5. 迭代器和生成器 -->
                <section id="section-5" class="content-section p-6 mb-8">
                    <h2 class="section-title text-2xl font-bold">
                        <i class="fas fa-sync-alt"></i>
                        迭代器和生成器
                    </h2>
                    <div class="space-y-6">
                        <!-- 迭代器 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">迭代器是实现了迭代器协议的对象</h3>
                            <ul class="list-disc pl-6 space-y-2">
                                <li>Python中没有像<code>protocol</code>或<code>interface</code>这样的定义协议的关键字。</li>
                                <li>Python中用魔术方法表示协议。</li>
                                <li><code>__iter__</code>和<code>__next__</code>魔术方法就是迭代器协议。</li>
                            </ul>
                            <pre><code class="language-python">class Fib(object):
    """迭代器"""
    
    def __init__(self, num):
        self.num = num
        self.a, self.b = 0, 1
        self.idx = 0
   
    def __iter__(self):
        return self

    def __next__(self):
        if self.idx < self.num:
            self.a, self.b = self.b, self.a + self.b
            self.idx += 1
            return self.a
        raise StopIteration()</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- 生成器 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">生成器是语法简化版的迭代器</h3>
                            <pre><code class="language-python">def fib(num):
    """生成器"""
    a, b = 0, 1
    for _ in range(num):
        a, b = b, a + b
        yield a</code><button class="copy-btn">复制</button></pre>
                        </div>
                        
                        <!-- 生成器进化为协程 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">生成器进化为协程</h3>
                            <p>生成器对象可以使用<code>send()</code>方法发送数据，发送的数据会成为生成器函数中通过<code>yield</code>表达式获得的值。这样，生成器就可以作为协程使用，协程简单的说就是可以相互协作的子程序。</p>
                            
                            <h4 class="text-lg font-semibold mt-4 mb-2">例子：流式计算平均值</h4>
                            <pre><code class="language-python">def calc_avg():
    """流式计算平均值"""
    total, counter = 0, 0
    avg_value = None
    while True:
        value = yield avg_value
        total, counter = total + value, counter + 1
        avg_value = total / counter

gen = calc_avg()
next(gen)
print(gen.send(10))  # 10.0
print(gen.send(20))  # 15.0
print(gen.send(30))  # 20.0</code><button class="copy-btn">复制</button></pre>
                        </div>
                    </div>
                </section>

                <!-- 6. 并发编程 -->
                <section id="section-6" class="content-section p-6 mb-8">
                    <h2 class="section-title text-2xl font-bold">
                        <i class="fas fa-network-wired"></i>
                        并发编程
                    </h2>
                    <div class="space-y-6">
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">并发编程概述</h3>
                            <p>Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。</p>
                        </div>

                        <!-- 多线程 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">多线程</h3>
                            <p>Python中提供了<code>Thread</code>类并辅以<code>Lock</code>、<code>Condition</code>、<code>Event</code>、<code>Semaphore</code>和<code>Barrier</code>。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的。</p>

                            <h4 class="text-lg font-semibold mt-4 mb-2">多线程示例：生成图片缩略图</h4>
                            <pre><code class="language-python">  """
  面试题：进程和线程的区别和联系？
  进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程
  线程 - 操作系统分配CPU的基本单位
  并发编程（concurrent programming）
  1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行
  2. 改善用户体验 - 让耗时间的操作不会造成程序的假死
  """
  import glob
  import os
  import threading
  
  from PIL import Image
  
  PREFIX = 'thumbnails'
  
  
  def generate_thumbnail(infile, size, format='PNG'):
      """生成指定图片文件的缩略图"""
  	file, ext = os.path.splitext(infile)
  	file = file[file.rfind('/') + 1:]
  	outfile = f'{PREFIX}/{file}_{size[0]}_{size[1]}.{ext}'
  	img = Image.open(infile)
  	img.thumbnail(size, Image.ANTIALIAS)
  	img.save(outfile, format)
  
  
  def main():
      """主函数"""
  	if not os.path.exists(PREFIX):
  		os.mkdir(PREFIX)
  	for infile in glob.glob('images/*.png'):
  		for size in (32, 64, 128):
              # 创建并启动线程
  			threading.Thread(
  				target=generate_thumbnail, 
  				args=(infile, (size, size))
  			).start()
  			
  
  if __name__ == '__main__':
  	main()</code><button class="copy-btn">复制</button></pre>
                        </div>

                        <!-- 多进程 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">多进程</h3>
                            <p>多进程可以有效的解决GIL的问题，实现多进程主要的类是<code>Process</code>，其他辅助的类跟<code>threading</code>模块中的类似。</p>

                            <h4 class="text-lg font-semibold mt-4 mb-2">多进程示例：判断素数</h4>
                            <pre><code class="language-python">import concurrent.futures
import math

PRIMES = [
    1116281, 1297337, 104395303, 472882027, 533000389,
    817504243, 982451653, 112272535095293
] * 5

def is_prime(n):
    """判断素数"""
    if n % 2 == 0:
        return False
    sqrt_n = int(math.floor(math.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2):
        if n % i == 0:
            return False
    return True

def main():
    """主函数"""
    with concurrent.futures.ProcessPoolExecutor() as executor:
        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):
            print('%d is prime: %s' % (number, prime))</code><button class="copy-btn">复制</button></pre>

                            <blockquote>
                                <p><strong>重点</strong>：<strong>多线程和多进程的比较</strong>。</p>
                                <p>以下情况需要使用多线程：</p>
                                <ol>
                                    <li>程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的。</li>
                                    <li>程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。</li>
                                </ol>
                                <p>以下情况需要使用多进程：</p>
                                <ol>
                                    <li>程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。</li>
                                    <li>程序的输入可以并行的分成块，并且可以将运算结果合并。</li>
                                    <li>程序在内存使用方面没有任何限制且不强依赖于I/O操作。</li>
                                </ol>
                            </blockquote>
                        </div>

                        <!-- 异步处理 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">异步处理</h3>
                            <p>异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务。Python 3通过<code>asyncio</code>模块和<code>await</code>和<code>async</code>关键字来支持异步处理。</p>

                            <h4 class="text-lg font-semibold mt-4 mb-2">异步I/O示例</h4>
                            <pre><code class="language-python">  """
  异步I/O - async / await
  """
  import asyncio
  
  
  def num_generator(m, n):
      """指定范围的数字生成器"""
      yield from range(m, n + 1)
  
  
  async def prime_filter(m, n):
      """素数过滤器"""
      primes = []
      for i in num_generator(m, n):
          flag = True
          for j in range(2, int(i ** 0.5 + 1)):
              if i % j == 0:
                  flag = False
                  break
          if flag:
              print('Prime =>', i)
              primes.append(i)
  
          await asyncio.sleep(0.001)
      return tuple(primes)
  
  
  async def square_mapper(m, n):
      """平方映射器"""
      squares = []
      for i in num_generator(m, n):
          print('Square =>', i * i)
          squares.append(i * i)
  
          await asyncio.sleep(0.001)
      return squares
  
  
  def main():
      """主函数"""
      loop = asyncio.get_event_loop()
      future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100))
      future.add_done_callback(lambda x: print(x.result()))
      loop.run_until_complete(future)
      loop.close() 
  
  
  if __name__ == '__main__':
      main()</code><button class="copy-btn">复制</button></pre>

                                  <blockquote>
                                <p><strong>说明</strong></p>
                                <p>上面的代码使用`get_event_loop`函数获得系统默认的事件循环，通过`gather`函数可以获得一个`future`对象，`future`对象的`add_done_callback`可以添加执行完成时的回调函数，`loop`对象的`run_until_complete`方法可以等待通过`future`对象获得协程执行结果。</p>
                            </blockquote>

                            <p>Python中有一个名为`aiohttp`的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟`asyncio`模块一起工作，并提供了对`Future`对象的支持。Python 3.6中引入了`async`和`await`来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。</p>

                            <h4 class="text-lg font-semibold mt-4 mb-2">代码异步示例</h4>
                            <p>从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。</p>
                            <pre><code class="language-python">    import asyncio
  import re
  
  import aiohttp
  
  PATTERN = re.compile(r'&lt;title&gt;(?P&lt;title&gt;.*)&lt;/title&gt;')
    
  async def fetch_page(session, url):
      async with session.get(url, ssl=False) as resp:
          return await resp.text()
  
  
  async def show_title(url):
      async with aiohttp.ClientSession() as session:
          html = await fetch_page(session, url)
          print(PATTERN.search(html).group('title'))
  
  
  def main():
      urls = ('https://www.python.org/',
              'https://git-scm.com/',
              'https://www.jd.com/',
              'https://www.taobao.com/',
              'https://www.douban.com/')
      loop = asyncio.get_event_loop()
      cos = [show_title(url) for url in urls]
      loop.run_until_complete(asyncio.wait(cos))
      loop.close()
  
  
  if __name__ == '__main__':
      main()</code><button class="copy-btn">复制</button></pre>
                            
                            <blockquote>
                                <p><strong>重点</strong>：<strong>异步I/O与多进程的比较</strong>。</p>
                                <p>当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，<code>asyncio</code>就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑<code>asyncio</code>，它很适合编写没有实时数据处理需求的Web应用服务器。</p>
                            </blockquote>
                            <blockquote>
                                <p><strong>说明</strong></p>
                                <p>上面的代码使用`get_event_loop`函数获得系统默认的事件循环，通过`gather`函数可以获得一个`future`对象，`future`对象的`add_done_callback`可以添加执行完成时的回调函数，`loop`对象的`run_until_complete`方法可以等待通过`future`对象获得协程执行结果。</p>
                            </blockquote>


                        </div>

                        <!-- 其他并发处理方式 -->
                        <div class="card">
                            <h3 class="text-xl font-bold mb-4">其他并发处理方式</h3>
                            <p>Python还有很多用于处理并行任务的三方库，例如：<code>joblib</code>、<code>PyMP</code>等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。</p>
                            
                            <p class="mt-4">可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。</p>
                            
                            <p class="mt-4">要实现任务的异步化，可以使用名为<code>Celery</code>的三方库。<code>Celery</code>是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。</p>
                        </div>
                    </div>
                </section>

            <!-- 页脚 -->
            <footer class="mt-12 py-8 border-t border-gray-200 dark:border-gray-800">
                <div class="flex flex-col md:flex-row justify-between items-center">
                    <div class="mb-4 md:mb-0">
                        <p class="text-sm text-gray-600 dark:text-gray-400">© 2025 Python学习之旅. 保留所有权利。</p>
                    </div>
                    <div class="flex space-x-4">
                        <a href="#" class="text-gray-500 hover:text-blue-500 dark:text-gray-400 dark:hover:text-blue-400">
                            <i class="fab fa-github"></i>
                        </a>
                        <a href="#" class="text-gray-500 hover:text-blue-500 dark:text-gray-400 dark:hover:text-blue-400">
                            <i class="fab fa-twitter"></i>
                        </a>
                        <a href="#" class="text-gray-500 hover:text-blue-500 dark:text-gray-400 dark:hover:text-blue-400">
                            <i class="fab fa-linkedin"></i>
                        </a>
                    </div>
                </div>
            </footer>
            </main>
        </div>
    </div>

    <!-- 返回顶部按钮 -->
    <button id="back-to-top" class="fixed bottom-8 right-8 bg-blue-500 text-white p-3 rounded-full shadow-lg opacity-0 transition-opacity duration-300 hover:bg-blue-600 focus:outline-none">
        <i class="fas fa-arrow-up"></i>
    </button>

    <!-- JavaScript -->
    <script>
        // 初始化Mermaid
        mermaid.initialize({
            startOnLoad: true,
            theme: window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default'
        });
        
        // DOM元素
        const body = document.body;
        const themeToggle = document.getElementById('theme-toggle');
        const tocToggle = document.getElementById('toc-toggle');
        const closeToc = document.getElementById('close-toc');
        const tocOverlay = document.getElementById('toc-overlay');
        const mobileToc = document.getElementById('mobile-toc');
        const backToTop = document.getElementById('back-to-top');
        const content = document.getElementById('content');
        const toc = document.getElementById('toc');
        const progressBar = document.getElementById('progressBar');
        
        // 主题切换
        function setTheme(isDark) {
            if (isDark) {
                body.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                mermaid.initialize({ theme: 'dark' });
            } else {
                body.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                mermaid.initialize({ theme: 'default' });
            }
        }
        
        // 检查用户偏好
        const userPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const savedTheme = localStorage.getItem('theme');
        
        if (savedTheme === 'dark' || (!savedTheme && userPrefersDark)) {
            setTheme(true);
        }
        
        // 主题切换事件
        themeToggle.addEventListener('click', () => {
            const isDark = body.classList.contains('dark');
            setTheme(!isDark);
        });
        
        // 移动端目录切换
        tocToggle.addEventListener('click', () => {
            mobileToc.classList.add('show');
            tocOverlay.classList.add('show');
        });
        
        closeToc.addEventListener('click', () => {
            mobileToc.classList.remove('show');
            tocOverlay.classList.remove('show');
        });
        
        tocOverlay.addEventListener('click', () => {
            mobileToc.classList.remove('show');
            tocOverlay.classList.remove('show');
        });
        
        // 返回顶部按钮
        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                backToTop.style.opacity = '1';
            } else {
                backToTop.style.opacity = '0';
            }
            // 更新进度条
            const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
            const scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight;
            const clientHeight = document.documentElement.clientHeight || window.innerHeight;
            const scrollPercentage = (scrollTop / (scrollHeight - clientHeight)) * 100;
            progressBar.style.width = scrollPercentage + '%';

        });
        
        backToTop.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
        
        // 生成目录
        function generateTOC() {
            const headings = content.querySelectorAll('h2, h3, h4');
            let tocHTML = '';
            
            headings.forEach(heading => {
                const id = heading.id || heading.textContent.toLowerCase().replace(/\s+/g, '-');
                heading.id = id;
                
                const level = parseInt(heading.tagName.substring(1)) - 2;
                const indent = level > 0 ? `ml-${level * 4}` : '';
                
                tocHTML += `<a href="#${id}" class="nav-link ${indent}">${heading.textContent}</a>`;
            });
            
            toc.innerHTML = tocHTML;
            
            // 复制到移动端目录
            document.querySelector('#mobile-toc nav').innerHTML = tocHTML;
            
            // 添加目录点击事件
            const tocLinks = document.querySelectorAll('.nav-link');
            tocLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    // 在移动端点击链接后关闭目录
                    if (window.innerWidth < 1024) {
                        mobileToc.classList.remove('show');
                        tocOverlay.classList.remove('show');
                    }
                });
            });
        }
        
        // 页面加载完成后生成目录
        document.addEventListener('DOMContentLoaded', generateTOC);

        // 学习进度模拟（仅作演示）
        const progressBars = {
            basic: document.querySelector('.progress-basic'),
            advanced: document.querySelector('.progress-advanced'),
            pro: document.querySelector('.progress-pro')
        };
        
        // 模拟进度更新
        function simulateProgress() {
            let basicProgress = 0;
            let advancedProgress = 0;
            let proProgress = 0;
            
            const interval = setInterval(() => {
                if (basicProgress < 75) {
                    basicProgress += 1;
                    progressBars.basic.style.width = `${basicProgress}%`;
                    progressBars.basic.parentElement.previousElementSibling.lastElementChild.textContent = `${basicProgress}%`;
                }
                
                if (basicProgress > 30 && advancedProgress < 45) {
                    advancedProgress += 1;
                    progressBars.advanced.style.width = `${advancedProgress}%`;
                    progressBars.advanced.parentElement.previousElementSibling.lastElementChild.textContent = `${advancedProgress}%`;
                }
                
                if (advancedProgress > 20 && proProgress < 20) {
                    proProgress += 1;
                    progressBars.pro.style.width = `${proProgress}%`;
                    progressBars.pro.parentElement.previousElementSibling.lastElementChild.textContent = `${proProgress}%`;
                }
                
                if (basicProgress >= 75 && advancedProgress >= 45 && proProgress >= 20) {
                    clearInterval(interval);
                }
            }, 50);
        }
        
        // 页面加载后延迟启动进度模拟
        setTimeout(simulateProgress, 1500);
        
        // 复制按钮功能
        document.addEventListener('click', function(e) {
            if (e.target && e.target.classList.contains('copy-btn')) {
                const codeBlock = e.target.previousElementSibling;
                const textToCopy = codeBlock.textContent;
                
                if (navigator.clipboard && window.isSecureContext) {
                    // 使用现代的 Clipboard API
                    navigator.clipboard.writeText(textToCopy).then(function() {
                        e.target.textContent = '已复制!';
                        setTimeout(function() {
                            e.target.textContent = '复制';
                        }, 2000);
                    }).catch(function(err) {
                        console.error('复制失败: ', err);
                    });
                } else {
                    // 降级方案：使用传统的 execCommand
                    const textArea = document.createElement('textarea');
                    textArea.value = textToCopy;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        document.execCommand('copy');
                        e.target.textContent = '已复制!';
                        setTimeout(function() {
                            e.target.textContent = '复制';
                        }, 2000);
                    } catch (err) {
                        console.error('复制失败: ', err);
                    }
                    
                    document.body.removeChild(textArea);
                }
            }
        });
    </script>
</body>
</html>